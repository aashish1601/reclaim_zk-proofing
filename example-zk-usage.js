// Example: How to use ZK proofs generated by your extension
// This file shows practical implementations for different use cases

// ============================================================================
// 1. BASIC ZK PROOF STRUCTURE (what your extension generates)
// ============================================================================

const exampleZKProof = {
    "proof": {
        "publicInputs": ["0x1234...", "0x5678..."],
        "verificationKey": "0xabcd...",
        "provider": "github",
        "username": "john_doe",
        "timestamp": 1640995200000
    },
    "metadata": {
        "sessionId": "abc123",
        "generatedAt": "2024-01-01T00:00:00Z",
        "provider": "github"
    }
};

// ============================================================================
// 2. SMART CONTRACT INTEGRATION
// ============================================================================

// Solidity contract for ZK proof verification
const ZKVerifierContract = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ZKProofVerifier {
    mapping(address => bool) public verifiedUsers;
    mapping(address => string) public userProviders;
    mapping(address => uint256) public verificationTimestamp;
    
    event UserVerified(address indexed user, string provider, uint256 timestamp);
    
    function verifyProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs,
        string calldata provider
    ) external returns (bool) {
        // Verify the ZK proof using your verification key
        bool isValid = verifyZKProof(proof, publicInputs);
        
        if (isValid) {
            verifiedUsers[msg.sender] = true;
            userProviders[msg.sender] = provider;
            verificationTimestamp[msg.sender] = block.timestamp;
            
            emit UserVerified(msg.sender, provider, block.timestamp);
            return true;
        }
        
        return false;
    }
    
    function isVerified(address user) external view returns (bool) {
        return verifiedUsers[user];
    }
    
    function getUserProvider(address user) external view returns (string memory) {
        return userProviders[user];
    }
    
    function getVerificationTimestamp(address user) external view returns (uint256) {
        return verificationTimestamp[user];
    }
    
    // Placeholder for actual ZK proof verification
    function verifyZKProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) internal pure returns (bool) {
        // TODO: Implement actual ZK proof verification
        // This would use the verification key from your WootzApp API
        return true; // Placeholder
    }
}
`;

// ============================================================================
// 3. FRONTEND INTEGRATION (React/JavaScript)
// ============================================================================

// React component for submitting ZK proofs
class ZKProofSubmitter extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            isSubmitting: false,
            result: null,
            error: null
        };
    }
    
    async submitProof(zkProof, contractAddress) {
        this.setState({ isSubmitting: true, error: null });
        
        try {
            // Connect to Ethereum
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const contract = new ethers.Contract(contractAddress, ABI, signer);
            
            // Parse the ZK proof data
            const proofData = JSON.parse(zkProof);
            
            // Submit to smart contract
            const tx = await contract.verifyProof(
                proofData.proof,
                proofData.publicInputs,
                proofData.provider
            );
            
            await tx.wait();
            
            this.setState({
                result: { success: true, txHash: tx.hash },
                isSubmitting: false
            });
            
        } catch (error) {
            this.setState({
                error: error.message,
                isSubmitting: false
            });
        }
    }
    
    render() {
        return (
            <div className="zk-proof-submitter">
                <button 
                    onClick={() => this.submitProof(this.props.zkProof, this.props.contractAddress)}
                    disabled={this.state.isSubmitting}
                >
                    {this.state.isSubmitting ? 'Submitting...' : 'Submit ZK Proof'}
                </button>
                
                {this.state.result && (
                    <div className="success-message">
                        ✅ Proof submitted successfully! 
                        <a href={`https://etherscan.io/tx/${this.state.result.txHash}`} target="_blank">
                            View Transaction
                        </a>
                    </div>
                )}
                
                {this.state.error && (
                    <div className="error-message">
                        ❌ Error: {this.state.error}
                    </div>
                )}
            </div>
        );
    }
}

// ============================================================================
// 4. API INTEGRATION (Node.js/Express)
// ============================================================================

const express = require('express');
const app = express();

// Middleware to verify ZK proofs
async function verifyZKProof(proof, publicInputs, verificationKey) {
    // TODO: Implement actual ZK proof verification
    // This would use the verification key from your WootzApp API
    
    // For now, we'll do a basic validation
    if (!proof || !publicInputs || !verificationKey) {
        return false;
    }
    
    // Add your verification logic here
    return true; // Placeholder
}

// API endpoint to verify and store ZK proofs
app.post('/api/verify-proof', async (req, res) => {
    try {
        const { proof, publicInputs, verificationKey, provider, userId } = req.body;
        
        // Verify the ZK proof
        const isValid = await verifyZKProof(proof, publicInputs, verificationKey);
        
        if (isValid) {
            // Store verification in database
            const verification = await db.verifications.create({
                userId,
                provider,
                verifiedAt: new Date(),
                proofHash: require('crypto').createHash('sha256').update(JSON.stringify(proof)).digest('hex')
            });
            
            // Grant access or permissions based on provider
            const permissions = getPermissionsForProvider(provider);
            await grantUserPermissions(userId, permissions);
            
            res.json({
                success: true,
                message: 'Proof verified successfully',
                verificationId: verification.id,
                permissions: permissions
            });
        } else {
            res.status(400).json({
                success: false,
                message: 'Invalid proof'
            });
        }
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
});

// Get user's verification status
app.get('/api/user/:userId/verifications', async (req, res) => {
    try {
        const verifications = await db.verifications.findAll({
            where: { userId: req.params.userId }
        });
        
        res.json({
            success: true,
            verifications: verifications
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
});

// ============================================================================
// 5. USE CASE EXAMPLES
// ============================================================================

// Example 1: DeFi Protocol Access
async function grantDeFiAccess(userAddress, zkProof) {
    const proofData = JSON.parse(zkProof);
    
    if (proofData.provider === 'github') {
        // Grant access to DeFi protocol
        await defiContract.grantAccess(userAddress, 'github_verified');
        return { success: true, accessGranted: true };
    }
    
    return { success: false, error: "GitHub verification required" };
}

// Example 2: NFT Gating
async function checkNFTAccess(zkProof, nftContract) {
    const proofData = JSON.parse(zkProof);
    
    if (proofData.provider === 'github' && proofData.isValid) {
        // Check if user can mint NFT
        const canMint = await nftContract.canMint(msg.sender);
        
        if (canMint) {
            await nftContract.mint(msg.sender);
            return { canMint: true, nftMinted: true };
        }
    }
    
    return { canMint: false, reason: "GitHub verification required" };
}

// Example 3: DAO Voting Rights
async function checkVotingRights(zkProof, daoContract) {
    const proofData = JSON.parse(zkProof);
    
    if (proofData.provider === 'linkedin') {
        // Check experience years from LinkedIn
        const experienceYears = proofData.experienceYears || 0;
        
        if (experienceYears >= 5) {
            await daoContract.grantVotingRights(msg.sender, 1);
            return { votingRights: true, weight: 1 };
        }
    }
    
    return { votingRights: false, reason: "5+ years experience required" };
}

// Example 4: Website Access Control
async function checkWebsiteAccess(zkProof) {
    const proofData = JSON.parse(zkProof);
    
    if (proofData.isValid && proofData.provider === 'github') {
        return { 
            access: true, 
            tier: 'premium',
            features: ['advanced_analytics', 'api_access', 'priority_support']
        };
    }
    
    return { access: false, tier: 'basic' };
}

// ============================================================================
// 6. INTEGRATION WITH YOUR EXTENSION
// ============================================================================

// Add this to your background script to store proofs
class ProofManager {
    constructor() {
        this.storedProofs = new Map();
    }
    
    storeProof(sessionId, proofData) {
        this.storedProofs.set(sessionId, {
            proof: proofData,
            timestamp: Date.now(),
            provider: this.getProviderFromSession(sessionId)
        });
        
        console.log(`[ProofManager] Stored proof for session: ${sessionId}`);
    }
    
    getProof(sessionId) {
        return this.storedProofs.get(sessionId);
    }
    
    getAllProofs() {
        return Array.from(this.storedProofs.values());
    }
    
    exportProofs() {
        return JSON.stringify(this.getAllProofs(), null, 2);
    }
    
    getProviderFromSession(sessionId) {
        // Extract provider from session ID or stored data
        // This depends on your session management
        return 'github'; // Placeholder
    }
}

// Initialize in your background script
const proofManager = new ProofManager();

// Listen for proof generation
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'PROOF_GENERATED') {
        proofManager.storeProof(message.sessionId, message.proofData);
        sendResponse({ success: true });
    }
    
    if (message.action === 'EXPORT_PROOFS') {
        const proofs = proofManager.exportProofs();
        sendResponse({ success: true, proofs: proofs });
    }
});

// ============================================================================
// 7. UTILITY FUNCTIONS
// ============================================================================

// Download proofs as JSON file
function downloadProofs(proofs, filename = 'zk-proofs.json') {
    const blob = new Blob([proofs], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Copy proof to clipboard
async function copyProofToClipboard(proof) {
    try {
        await navigator.clipboard.writeText(JSON.stringify(proof, null, 2));
        return { success: true, message: 'Proof copied to clipboard' };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

// Validate proof structure
function validateProof(proof) {
    const requiredFields = ['proof', 'metadata'];
    const proofFields = ['publicInputs', 'verificationKey', 'provider'];
    
    for (const field of requiredFields) {
        if (!proof[field]) {
            return { valid: false, error: `Missing required field: ${field}` };
        }
    }
    
    for (const field of proofFields) {
        if (!proof.proof[field]) {
            return { valid: false, error: `Missing proof field: ${field}` };
        }
    }
    
    return { valid: true };
}

// ============================================================================
// 8. EXAMPLE USAGE
// ============================================================================

// Example: How to use the ZK proof in your application
async function exampleUsage() {
    // 1. Get the ZK proof from your extension
    const zkProof = exampleZKProof;
    
    // 2. Validate the proof
    const validation = validateProof(zkProof);
    if (!validation.valid) {
        console.error('Invalid proof:', validation.error);
        return;
    }
    
    // 3. Use the proof for different purposes
    console.log('Using ZK proof for DeFi access...');
    const defiResult = await grantDeFiAccess('0x1234...', JSON.stringify(zkProof));
    
    console.log('Using ZK proof for NFT access...');
    const nftResult = await checkNFTAccess(JSON.stringify(zkProof), nftContract);
    
    console.log('Using ZK proof for DAO voting...');
    const daoResult = await checkVotingRights(JSON.stringify(zkProof), daoContract);
    
    console.log('Using ZK proof for website access...');
    const websiteResult = await checkWebsiteAccess(zkProof);
    
    // 4. Export or copy the proof
    await copyProofToClipboard(zkProof);
    downloadProofs(JSON.stringify(zkProof), 'my-zk-proof.json');
}

// Run the example
// exampleUsage(); 